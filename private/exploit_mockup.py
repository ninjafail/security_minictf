"""
The challenge is basically a one-time pad encryption, where the key can be used twice
"""

import pwn
from bitstring import BitArray


PATH_TO_MOCKUP = "../mockup"


def wait():
    p.recvuntil("0: leave \n".encode()).decode()


p = pwn.process([PATH_TO_MOCKUP, ''])
wait()

# enter bit mode
p.sendline('3'.encode())
wait()

# get flag and length
p.sendline('1'.encode())
flag = p.recvline().decode().split(':')[1].replace(' ', '').replace('\n', '')
flag_length = len(flag) // 8 
print(f"The flag is: {flag}")
print(f"The length of the flag is: {flag_length}")
wait()

# get (multiple of) keylength by encrypting unknown message (with known length 3) until 2 duplicates are found
# got to menu
p.sendline('2'.encode())
wait()
msg1 = ""
msg2 = ""
messages = []
while msg1 not in messages or msg2 not in messages:
    messages.append(msg1)
    msg1 = msg2
    p.sendline('2'.encode())
    msg2 = p.recvline().decode().split(':')[1].replace(' ', '').replace('\n', '')
    wait()

# get multiple of key length
key_length = (len(messages)-2)*3
print(f"The multiple length of the key is: {key_length}")
message_length_to_send = key_length - flag_length
print(f"The length of the message to send is: {message_length_to_send}")

# reset key
p.sendline('0'.encode())
wait()
p.sendline('9'.encode())
wait()

# encrypt unknown message until you reach start of key
p.sendline('2'.encode())
wait()
for i in range(message_length_to_send // 3):
    p.sendline('2'.encode())
    wait()

# encrypt known message with which you can obtain part of the key (we know plain text and cyphertext at this area)
p.sendline('1'.encode())
plain_msg = p.recvline().decode().split(':')[1].replace(' ', '').replace('\n', '')
encrypted_msg = p.recvline().decode().split(':')[1].replace(' ', '').replace('\n', '')
wait()

# use this part of the key to obtain plain text flag
plain_msg = BitArray(bin=plain_msg)
encrypted_msg = BitArray(bin=encrypted_msg)
flag = BitArray(bin=flag)

key_start = plain_msg ^ encrypted_msg
print(f"The flag got encrypted with: {key_start.tobytes().decode()}")
plain_flag = key_start ^ flag
print(f"And thus must have been: {plain_flag.tobytes().decode()}")









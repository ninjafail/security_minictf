"""
The challenge is basically a one-time pad encryption, where the key can be used twice
"""

import pwn
from bitstring import BitArray


PATH_TO_MOCKUP = "../mockup"


def wait():
    p.recvuntil("0: leave \n".encode()).decode()


def read_output(p: pwn.process) -> str:
    return p.recvline().decode().split(':')[1].replace(' ', '').replace('\n', '')


p = pwn.process([PATH_TO_MOCKUP, ''])
wait()

# enter bit mode
p.sendline('3'.encode())
wait()

# get flag and length
p.sendline('1'.encode())
encrypted_flag = p.recvline().decode().split(':')[1].replace(' ', '').replace('\n', '')
flag_length = len(encrypted_flag) // 8
print(f"The encrypted flag is: {encrypted_flag}")
print(f"The length of the flag is: {flag_length}")
wait()

# go to message menu
p.sendline('2'.encode())
wait()

# get (multiple of) key length by encrypting unknown message (with known length 3) until 2 duplicates are found
# TODO: We might change the minimum length to 5 or more, such that it works, if one duplicate is found
#  (Currently there are different parts of the key, that encrypt to the same cipher of length 3. Thus there would
#  be found an incorrect key length)
msg1 = ""
msg2 = ""
messages = []
while msg1 not in messages or msg2 not in messages:
    messages.append(msg1)
    msg1 = msg2
    p.sendline('2'.encode())
    msg2 = read_output(p)
    wait()

# calculate multiple of key length
key_length = (len(messages)-2)*3
print(f"The multiple length of the key is: {key_length}")
message_length_to_send = key_length - flag_length
print(f"The length of the message to send is: {message_length_to_send}")

# reset key
p.sendline('0'.encode())
wait()
p.sendline('9'.encode())
wait()

# encrypt unknown message (with known length 3) until you reach start of key
p.sendline('2'.encode())
wait()
for i in range(message_length_to_send // 3):
    p.sendline('2'.encode())
    wait()

# encrypt known message with which you can obtain part of the key (we know plain text and ciphertext at this area)
p.sendline('1'.encode())
plain_msg = read_output(p)
encrypted_msg = read_output(p)
wait()

# use this part of the key to obtain plain text flag
# convert string pseudo bits to actual BitArray to be able to calculate on them
plain_msg = BitArray(bin=plain_msg)
encrypted_msg = BitArray(bin=encrypted_msg)
encrypted_flag = BitArray(bin=encrypted_flag)

key_start = plain_msg ^ encrypted_msg
print(f"The flag got encrypted with: {key_start.tobytes().decode()}")
plain_flag = key_start ^ encrypted_flag
print(f"And thus must have been: {plain_flag.tobytes().decode()}")








